import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext
import hashlib
import os
import requests
import psutil
import time
import threading
import shutil
import re
from sklearn.ensemble import RandomForestClassifier
import pandas as pd

# Constants (replace with actual API key)
VIRUSTOTAL_API_KEY = 'your_virustotal_api_key_here'
VIRUSTOTAL_API_URL = 'https://www.virustotal.com/api/v3/files/'
QUARANTINE_DIR = "C:/Quarantine/"  # Folder to quarantine suspicious files

# Ensure the Quarantine Directory exists
if not os.path.exists(QUARANTINE_DIR):
    os.makedirs(QUARANTINE_DIR)

# Initialize machine learning model (using dummy data for now)
def train_ml_model():
    data = pd.DataFrame({
        'size': [1024, 2048, 5120, 1280],
        'last_modified': [1625577380, 1625577480, 1625577580, 1625577680],
        'is_malicious': [0, 1, 0, 1]
    })
    X = data[['size', 'last_modified']]
    y = data['is_malicious']
    model = RandomForestClassifier()
    model.fit(X, y)
    return model

ml_model = train_ml_model()

# Utility Functions
def calculate_file_hash(file_path):
    hash_func = hashlib.sha256()
    with open(file_path, 'rb') as f:
        while chunk := f.read(8192):
            hash_func.update(chunk)
    return hash_func.hexdigest()

def scan_file_for_signature(file_path):
    file_hash = calculate_file_hash(file_path)
    headers = {"x-apikey": VIRUSTOTAL_API_KEY}
    url = VIRUSTOTAL_API_URL + file_hash
    response = requests.get(url, headers=headers)
   
    if response.status_code == 200:
        json_response = response.json()
        data = json_response.get('data', {})
        scan_results = data.get('attributes', {}).get('last_analysis_results', {})
       
        if scan_results:
            for engine, result in scan_results.items():
                if result['category'] == 'malicious':
                    return f"Malware Detected: {result.get('engine_name', 'Unknown')} flagged this file"
            return "File is clean according to VirusTotal"
        return "No analysis results available"
    return "Error in contacting VirusTotal API"

# File Quarantine Functionality
def quarantine_file(file_path):
    if not os.path.exists(QUARANTINE_DIR):
        os.makedirs(QUARANTINE_DIR)

    file_name = os.path.basename(file_path)
    quarantine_path = os.path.join(QUARANTINE_DIR, file_name)

    try:
        shutil.move(file_path, quarantine_path)
        return f"File quarantined successfully at: {quarantine_path}"
    except Exception as e:
        return f"Error quarantining file: {str(e)}"

def delete_file(file_path):
    try:
        os.remove(file_path)
        return f"File deleted successfully: {file_path}"
    except Exception as e:
        return f"Error deleting file: {str(e)}"

# Improved Ransomware Detection
def detect_ransomware_behavior():
    monitored_dir = "C:/Users/"  # Directory to monitor (adjust as needed)
    suspicious_files = []
    mass_modification_threshold = 20  # Number of files modified in a short time to consider suspicious

    modified_files = []  # List to track recently modified files
    now = time.time()

    # Check for encrypted file extensions or mass modifications
    for foldername, subfolders, filenames in os.walk(monitored_dir):
        for filename in filenames:
            file_path = os.path.join(foldername, filename)
            try:
                last_modified_time = os.path.getmtime(file_path)
                current_time = time.time()
               
                # Detect file modifications within the last 5 minutes
                if current_time - last_modified_time < 300:  # 5 minutes
                    modified_files.append(file_path)
                   
                    # Check for ransomware-like extensions (.locked, .crypt, .enc, etc.)
                    suspicious_extensions = ['.locked', '.crypt', '.enc', '.aes']
                    if any(file_path.endswith(ext) for ext in suspicious_extensions):
                        suspicious_files.append(f"Suspicious encrypted file detected: {file_path}")

                    # Check for large file size changes (possible sign of encryption)
                    file_size = os.path.getsize(file_path)
                    initial_size = file_size  # Store initial size (could store initial state in a DB or log)
                    if file_size < 500:  # Very small files might indicate encryption
                        suspicious_files.append(f"Suspicious small file detected: {file_path} (Size: {file_size} bytes)")

            except FileNotFoundError:
                continue

    # If many files were modified in a short time, flag it
    if len(modified_files) >= mass_modification_threshold:
        suspicious_files.append(f"Warning: {len(modified_files)} files modified recently. This might indicate ransomware activity.")

    return suspicious_files

# GUI Application Class
class AntivirusApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Python Antivirus")
        self.root.geometry("750x550")
        self.root.configure(bg="#f4f4f9")
       
        # Title and Instructions
        self.title_label = tk.Label(root, text="Real Time Sandboxing", font=("Arial", 20), bg="#f4f4f9", fg="#333")
        self.title_label.pack(pady=20)

        self.instructions_label = tk.Label(root, text="Select a file to scan or monitor system processes.", font=("Arial", 12), bg="#f4f4f9", fg="#555")
        self.instructions_label.pack(pady=10)

        # Buttons for Scanning and Monitoring
        self.scan_button = tk.Button(root, text="Scan File for Malware", command=self.scan_file, width=30, height=2, bg="#28a745", fg="white", font=("Arial", 12), relief="flat")
        self.scan_button.pack(pady=15)
       
        self.monitor_button = tk.Button(root, text="Monitor System Processes", command=self.monitor_system, width=30, height=2, bg="#007bff", fg="white", font=("Arial", 12), relief="flat")
        self.monitor_button.pack(pady=10)

        self.real_time_button = tk.Button(root, text="Start Real-Time Monitoring", command=self.start_real_time_monitoring, width=30, height=2, bg="#ffc107", fg="white", font=("Arial", 12), relief="flat")
        self.real_time_button.pack(pady=10)

        # Result and log display area
        self.result_label = tk.Label(root, text="Results will be displayed here.", font=("Arial", 12), fg="red", bg="#f4f4f9")
        self.result_label.pack(pady=20)

        # Status Bar at the bottom
        self.status_label = tk.Label(root, text="Status: Ready", font=("Arial", 10), fg="black", bg="#f4f4f9")
        self.status_label.pack(side="bottom", fill="x", padx=5, pady=5)

        # Log Display Area
        self.log_text = scrolledtext.ScrolledText(root, width=80, height=10, font=("Courier New", 10), wrap=tk.WORD, bg="#000000")
        self.log_text.pack(pady=10)
        self.log_text.insert(tk.END, "Activity Log:\n\n")

    def scan_file(self):
        file_path = filedialog.askopenfilename(title="Select a File to Scan")
        if file_path:
            self.set_status("Scanning file...")
            result = self.scan_and_analyze_file(file_path)
            self.display_result(result)

    def scan_and_analyze_file(self, file_path):
        vt_result = scan_file_for_signature(file_path)
       
        # Perform machine learning-based prediction
        ml_result = self.predict_malicious_file(file_path)

        # Optionally, quarantine or delete the file
        action = self.ask_for_action()
        if action == "Quarantine":
            quarantine_result = quarantine_file(file_path)
            return f"{vt_result}\n{ml_result}\n{quarantine_result}"
        elif action == "Delete":
            delete_result = delete_file(file_path)
            return f"{vt_result}\n{ml_result}\n{delete_result}"
        else:
            return f"{vt_result}\n{ml_result}"

    def predict_malicious_file(self, file_path):
        file_size = os.path.getsize(file_path)
        last_modified = int(os.path.getmtime(file_path))
        prediction = ml_model.predict([[file_size, last_modified]])[0]
        return "Malicious File Detected" if prediction == 1 else "File is clean."

    def ask_for_action(self):
        action = messagebox.askquestion("Action", "What would you like to do with the suspicious file?", icon='warning', type='yesnocancel')
        if action == "yes":
            return "Quarantine"
        elif action == "no":
            return "Delete"
        return "Ignore"

    def monitor_system(self):
        self.set_status("Monitoring system processes...")
        result = self.monitor_processes()
        self.display_result(result)

    def monitor_processes(self):
        suspicious_patterns = ['cmd.exe', 'regedit.exe', 'shutdown.exe', 'netstat.exe', 'del.exe', 'taskkill.exe']
        suspicious_processes = []

        for proc in psutil.process_iter(attrs=['pid', 'name']):
            process_name = proc.info['name'].lower()
            if any(pattern in process_name for pattern in suspicious_patterns):
                suspicious_processes.append(f"Suspicious Process Detected: {proc.info['name']} (PID: {proc.info['pid']})")

        return "\n".join(suspicious_processes) if suspicious_processes else "No suspicious processes found."

    def start_real_time_monitoring(self):
        threading.Thread(target=self._start_real_time_monitoring, daemon=True).start()
        self.set_status("Real-time monitoring started.")

    def _start_real_time_monitoring(self):
        while True:
            time.sleep(1)
            # Detect ransomware or unusual file changes
            suspicious_files = detect_ransomware_behavior()
            if suspicious_files:
                self.set_status(f"Suspicious activity detected: {len(suspicious_files)} suspicious files modified recently.")
                self.display_result("\n".join(suspicious_files))

    def display_result(self, result):
        self.result_label.config(text=result)
        self.log_text.insert(tk.END, f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {result}\n")
        self.log_text.yview(tk.END)  # Scroll to the latest log

    def set_status(self, status_text):
        self.status_label.config(text=f"Status: {status_text}")

# Run the application
if __name__ == "__main__":
    root = tk.Tk()
    app = AntivirusApp(root)
    root.mainloop()
